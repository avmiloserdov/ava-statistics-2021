# ava-statistics-2
**1) Корреляционный анализ**

Корреляционный анализ — метод обработки статистических данных, с помощью которого измеряется теснота связи между двумя или более переменными.

Для запуска скрипта с входными параметрами необходимо ввести команду в терминале

Rscript <название исполняемого скрипта с расширением> <имя файла и путь, если файл находится в другой директории> <номер листа в книге excel> <первый столбец для анализа> <второй столбец для анализа> )

В данном скрипте реализован анализа, использующий метод коррелции Пирсона. 

Работа скрипта: 
 1. считывание аргументов из консоли/термнала (считывание начинается с 6 аргумента, первые 5 заняты системными аргументами)
 
 args <- commandArgs()
 
 print(args)
 
 n <- as.numeric(args[7])
 
 df <- openxlsx::read.xlsx(args[6], sheet = n)

 2. запускается фильтр пропущенных значений, чтобы анализ дал корректрный результат 
 
 t <-  Filter(function(x)!all(is.na(x)), df)

 3. проводится анализ по 2 колонкам и выводится результат в терминал
 
 a <- cor.test(x=t[[args[8]]], y=t[[args[9]]], meth)
 
 print(a)
 
 Замечание: анализ проводится с численными значениями. 


**2) Выгрузка кусков таблиц**

Данный скрипт был запрошен заказчиком для того, чтобы можно было получать только конкретные части таблиц по определнным критериям. 

Для запуска скрипта с входными параметрами необходимо ввести команду в терминале

Rscript <название исполняемого скрипта с расширением> <имя файла и путь, если файл находится в другой директории> <номер листа в книге excel> <количество элементов выбранных для выгрузки части таблицы> <столбец, в котором будет происходить поиск элементов для выгрузки> <элемент 1> <элемент 2> и т.д.)

Принцип работы скрипта: 
 1. считывание аргументов из консоли/термнала (считывание начинается с 6 аргумента, первые 5 заняты системными аргументами)
 
 args <- commandArgs()
 
 k <- as.numeric(args[7])
 
 df <- openxlsx::read.xlsx(args[6], sheet = k)
 2. создание вектора, содержащего все элементы для выгрузки
 
 m <- 10 + as.numeric(args[8])
 
 l <- c()
 
 for (i in 10:m) {
  
  l <- append(l,args[i])
 
 }
 3. выгрузка части таблицы по выбранным криетриям и создание файла, содержащего необходимый кусок таблицы
 
 df_1 <- subset(df, df[[args[9]]] %in% l)

 
 print(df_1)
 
 write.xlsx(df_1, file = "subset.xlsx")

**3) Значение в опрделенном столбце**

В работе возникла необходимость знать все элементы в определнных столбцах.
Для запуска скрипта с входными параметрами необходимо ввести команду в терминале

Rscript <название исполняемого скрипта с расширением> <имя файла и путь, если файл находится в другой директории> <номер листа в книге excel> )

Принцип работы скрипта: 
 1. считывание аргументов из консоли/термнала (считывание начинается с 6 аргумента, первые 5 заняты системными аргументами)
 
 args <- commandArgs()
 
 k <- as.numeric(args[7])
 
 df <- openxlsx::read.xlsx(args[6], sheet = k)
 
 2. элементы в столбце и вывод их в консоль
 
 for (i in df[,1]) {
 
  print(i)

}

Замечение: вместо номера столбца, можно записать args[8] и автоматизировать данный скрипт для любого столбца, однако в нашем случае такой необходимости не было. 

Данный скрипт был использован для двух столбцов. 

**4) Кластерный анализ (коэффициент Жаккара и построение дендрограммы)**

Кластерный анализ - многомерная статистическая процедура, выполняющая сбор данных, содержащих информацию о выборке объектов, и затем упорядочивающая объекты в сравнительно однородные группы

Необходимо было реализовать кластерный анализ, используя коээфициент сходства Жаккара (https://ru.wikipedia.org/wiki/Коэффициент_Жаккара). 

Для запуска скрипта с входными параметрами необходимо ввести команду в терминале

Rscript <название исполняемого скрипта с расширением> <имя файла и путь, если файл находится в другой директории> <номер листа в книге excel> )

Принцип работы скрипта: 
 1. считывание аргументов из консоли/термнала (считывание начинается с 6 аргумента, первые 5 заняты системными аргументами)
 
 args <- commandArgs()
 
 k <- as.numeric(args[7])
 
 df <- openxlsx::read.xlsx(args[6], sheet = k)
 
 2. удаление первых столбцов и создание названия строк названиеми растений, затем транспонирование таблицы для построение дендрограммы по именам описаний
 
 df[,1] <- NULL
 
 df[,1] <- NULL
 
 row.names(df) <- df[,1]
 
 df[,1] <- NULL

 
 df <- t(df)

 3. Затем создается матрицы сходства и проводится класетрный анализ 
 
 d <- vegdist(df, method = "jaccard"); d
 
 fit <- hclust(d, method = "single")
 
 4. Построение дендрограммы
 
 plot(fit, labels=rownames(data), ylab='Jaccard Index', xlab = ' ',cex=0.5, main = 'Cluster dendrogram, Jaccard index')
 
 abline(h = 0.5)


data processing methods
